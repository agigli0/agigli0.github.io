My project is a JavaScript application that allows users to visualize the trajectory of a projectile with certain initial conditions and with air resistance factored in. This project incorporates what I have learned about efficient code and writing JavaScript, HTML, and CSS in CS50, as well as what I have learned from physics about air resistance. I made this app because it is not always obvious how well an object will travel based on its properties, and this visualization might help a physics student better understand the effects that physical properties have on trajectory. Anybody with curiosity should be able to use this app, regardless of CS proficiency.

This project consisted of three major steps:

	1) Modeling the physics in code
	2) Visualizing the physics
	3) Creating a graphical user interface

Initially, I wanted to have a three-dimensional environment that a user could manipulate to look at a pretty arc in space. During the development process, I realized that a two-dimensional approach made far more sense for a number of reasons:
	
	1) My physics had the projectile moving in at most two dimensions.
	2) 3D graphics are far more computationally intensive.
	3) It is difficult to program a 2D information overlay on top of a 3D graphics scene.

I chose JavaScript because it has object capability and runs in a web browser, meaning I could create a graphical user interface on any operating system. It also allowed me to use the p5.js library, which draws the trajectory on the webpage and animates the projectile. Another huge benefit of having it run in-browser is that I could theoretically host index.html on a server and let anybody use my software.


1) Modeling the physics

At first, I wrote the air-resistance modeling in Python because it was the language that I was most comfortable using. I later ported the code to JavaScript because I wanted to have a GUI. A nice feature of the GUI library p5 is that it has vector object notation. Inside projectile.js you will find most of the code for simulating projectile motion. A Projectile() object stores the properties of the projectile and its initial conditions, and it has a number of methods that run physics calculations.

The resistance_force() function takes full advantage of p5's vector notation to calculate the air resistance force as a function of veloicty. The update() function uses Euler's method to update position and velocity of the projectile as a function of the resistance force. I later implemented the fourth-order Runge-Kutta numerical integration method in updateRK4() because it is far more accurate at a given time resolution. Time resolution turned out not to be a problem for computing points but for graphing points, so I needed to limit the number of points sampled.


2) Visualizing the physics

Most of the heavy lifting takes place in calculate.js. This script takes care of grabbing the input values from the webpage, checking them for absurdity, and choosing an appropriate time step size based on expected time to hit the ground. It then runs updateRK4() with the given time step size until the projectile hits the ground, storing the positions and velocities of the projectile with every step. After the function has a full set of points, it runs a set of calculations to determine the scaling factors for the graph to be plotted. I could have used a plotting library like d3, but I wanted to keep a constant 1:1 x-y aspect ratio to accurately depict the trajectory of the projectile, and it ended up being less code to program a single-purpose grapher than to modify d3 for my purposes. I could have used d3 for the velocity-time graph, but I had already created lightweight graphing code for the x-y graph, so I figured that I would use it again with a few tweaks.

p5 structure has two main functions: setup() and draw(). setup() runs once and creates a canvas on the webpage. draw() tries to run sixty times every second and draws whatever is inside of it. setup() lives inside setup.js, and draw() inside draw.js. Inside draw(), there are two functions, position() and speed(), which do largely the same thing but with different kinds of data. I have to do a number of things. Using the scale factor from calculate.js, draw() plots axes, tick marks, gridlines, and labels. Then, using the scale factor and the points from inside points[], it creates a vertex at each position and draws a line between each vertex. Because there are so many vertices, the curve appears smooth. I also wanted there to be a projectile moving along the curve so that users could visualize the time dimension. The circle that zips along the arc uses a time-scaled factor to pick a point in the points[] array that corresponds to where the projectile would be at a given time. I also have the circle's color change as a funciton of speed relative to maximum speed: magenta is faster, cyan is slower. Lastly, I have some metrics in the top right corner so that I can understand how the application responds to various inputs. If the framerate dips, it means draw() is working too hard. If the millisecond number is too high, it means that calculate() is inefficient. The number of points is too high, then I need to drop the resolution. I aim for at least 1000 points.


3) GUI

HTML is fantastic for building interfaces because it is so simple. I used the Bootstrap CSS stylesheet to pretty up the interface. The HTML is very simple, only a few input fields, two buttons, and a bunch of <script> tags to integrate all that JavaScript. I learned a neat feature while developing this app: HTML allows for restricted input fields, effectively validating the form. I only needed minimal validation JavaScript to prevent users from crashing the app. I also needed no backend. The whole thing runs in-browser, and it turns out that my old machine from 2008 is more than fast enough to run accurate simulations.

The "Calculate" button triggers calculate(), and the "Export" button trigger exportify(), which saves the point data in a .csv file. "Screenshot" triggers screenshot(), which should export a .png screenshot of the graph, but p5 has spotty support for browsers—the screenshot functions stopped working after a Chrome update, but stil works in my version of Safari.


There are a few paths that I did not take.

	- I considered accounting for the rotation of the projectile and the Magnus force, but its very fickle and chaotic. There's a chance that the projectile never hits the ground, or at least not after any reasonable time.
	- For similar reasons, I did not want to incorporate wind speed. There was a good chance that the wind would blow the projectile arbitrarily far or stop the projectile from hitting the ground.
	- I did not have time to implement a function that changed air density as a function of altitude because I have a poor understanding of gas and atmospheric physics.

All in all, I got way further than I ever thought I would, and I'm proud of my finished product.

Here’s the video link, by the way:
https://youtu.be/aEAgOFQ3EOU
